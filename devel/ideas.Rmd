
# Simulation

OK, so when I have the data, I want to apply some fancy statistical model. Using a `lapply` on the list of `data.frame`s should do the job. Still there are some features which are missing, but often return:

- Error handling - what happens if my great model is not so great on all data sets
- Add the predictions to each data set
- Return some sort of result object - data frame and model fit
- It should be possible to apply several statistical methods and still have meaningful output
- The possibility to do this in parallel
- Storing some standard Quality Measures - BIAS, RBIAS, RMSE, RRMSE
- For large amount of data maybe it should be possible to supply not a list but a directory - this is probably not necessary
- For long running simulations I want to have a status bar, like in plyr - this conflicts with parallel
- For long running simulations the results should be stored in a file, csv-File using append, writing just a table - this allows to check the results - before all iterations are completed

<div class="tree" style="height: 200px;" markdown="1">
- [Phase 2: Simulation]()
  - [Applying statistical model]()
  - [Storing results]()
  - [Computing Quality Measures]()
</div>

## Applying statistical model

OK, so what features should this aspect have. I need a function which given one or more statistical models, will apply these model on each given data.frame. In principle this can be done by some call to `lapply` or `mclapply` in parallel. Adding some conventions for in and output will be necessary. Let's begin with the syntax:

~~~ r
sim_setup(setup, sim_model(list(fhWrapper, meanWrapper)))
# or
setup %+% sim_model()
# or - loosing the infos from the setup
sim_run(setup, sim_model(list(fh = fhWrapper, mean = meanWrapper)))
~~~

I don't know yet if I should stick to the 'sim_setup' notation, or seperate it from each other. The `%+%` operator is nice - it also forces me to think about class inheritance. On the other hand, what happens to the already defined methods. They should still work, if I add new components.

## Storing results

Some conventions for the supplied model, i.e. `fhWrapper`. The supplied model function only gets the data.frame for estimation. I could use `...` to pass other arguments, but I would have to control to which model-function additional arguments should be passed. At the moment I do not want that. So `fhWrapper` takes one argument, `dat`, and returns a `list`. The returned list can have as many elements as you like, however the first element is a `data.frame` with 2 columns, `idD` and `pred`, so the domain id and the prediction. These will be added to the data as `pred[ModelName]`. The other elements of the returned list, can be some meta information, like estimated parameters, if the algorithm converged etc. - these elements will be added as attribute to each `data.frame` - you can process this information as you like. If you specify a file, the output will be stored in one csv file with append. All `data.frames` have the same variable names, so appending is no problem, they also have the variable `idR` so you can distinguish between the simulation runs. The default file name is the name of the setup (given as `simName`). If the other list elements are data.frames and can be combined with rbind, they will also be stored in a file. If they are no data.frames then they are lost (iff you want to store results in a file).

~~~ r
fhWrapper(sim(setup[[1]]))
~~~

## Computing Quality Measures

After the predictions (of all models) have been added to the simulated data, they can be combined using something like `rbind`. Then you can compute quality measures, like the BIAS, RBIAS, RMSE and RRMSE - these measures are computed for each domain. For this use the following code:

~~~ r
sim_calc(calc_QM(qm = c("BIAS", "RBIAS", "RMSE", "RRMSE")))
~~~

Adding this component adds an attribute to the resulting list. A `data.frame` containing the computed quality measures. It will have the following identificators: `idD`, `simName`, `modelName`, `qm` and one variable named `value` for the computed value.

# Reporting

<div class="tree" style="height: 200px;" markdown="1">
- [Phase 3: Reporting]()
  - [Table for simulation scenario]()
  - [Tables for Quality Measures]()
  - [Plots for Quality Measures]()
    - [Boxplots]()
    - [Bland-Altmann]()
</div>

# More stuff:
  - sim_calc function which takes data as input - for linear models