<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Adding Computations}
-->
```{r include=FALSE}
options(markdown.HTML.header = system.file('misc', 'vignette.css', package='knitr'))
set.seed(1)
```

# sim_comp

Here follow some examples how to add components for computation to a `sim_setup`. Three points can be accessed with 

- `sim_comp_pop` - add a computation before sampling
- `sim_comp_sample` - add a computation after sampling
- `sim_comp_agg` - add a computation after aggregation

```{r}
library(saeSim)
base_id(2, 3) %>% sim_gen_x() %>% sim_gen_e() %>% sim_gen_ec() %>% 
  sim_resp_eq(y = 100 + x + e) %>%
  sim_comp_pop(comp_var(popMean = mean(y)), by = "idD")

```

The function `comp_var` is a wrapper around `dplyr::mutate` so you can add simple data manipulations. The argument `by` is a little extension and lets you define operations in the scope of groups identified by a variable in the data.

# Pre-configured components

Some statistics will be of interest frequently, which is why some predefined components are available.

- `sim_comp_n()` - adds the sample sizes in `n`
- `sim_comp_N()` - adds the population N in `N`
- `sim_comp_popMean()` - adds the population means
- `sim_comp_popVar()` - adds the population variances

```{r}
sim_base_lm() %>% 
  sim_comp_N() %>% 
  sim_comp_popMean() %>% 
  sim_comp_popVar() %>%
  sim_sample() %>% 
  sim_comp_n()
```

# Add custom computation functions

By adding computation functions you can extend the functionality of a sim_setup to wrap up your whole simulation. This will seperate the utility of this package from simply generating data. Add for example the linear predictor to the data:

```{r}
comp_linearPredictor <- function(dat) {
  dat$linearPredictor <- lm(y ~ x, dat) %>% predict
  dat
}

sim_base_lm() %>% 
  sim_comp_pop(comp_linearPredictor)
```

Or, should this be desiarable, directly produce a list of `lm` objects or add them as attribute to the data. However, the intended way of writing functions is that they will return the modified data set and has class 'data.frame'. 

```{r}
sim_base_lm() %>% 
  sim_comp_pop(function(dat) lm(y ~ x, dat)) %>%
  sim(R = 1)

comp_linearModelAsAttr <- function(dat) {
  attr(dat, "linearModel") <- lm(y ~ x, dat)
  dat
}

dat <- sim_base_lm() %>% 
  sim_comp_pop(comp_linearModelAsAttr) %>%
  as.data.frame

attr(dat, "linearModel")
```

If you use any kind of sampling, the 'linearPredictor' can be added after sampling. This is where small area models are supposed to be applied.

```{r}
sim_base_lm() %>% 
  sim_sample() %>%
  sim_comp_sample(comp_linearPredictor)
```

Should you want to apply area level models, use `sim_comp_agg` instead.

```{r}
sim_base_lm() %>% 
  sim_sample() %>%
  sim_agg() %>% 
  sim_comp_agg(comp_linearPredictor)
```

