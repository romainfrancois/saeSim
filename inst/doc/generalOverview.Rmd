<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction}
-->
```{r include=FALSE}
options(markdown.HTML.header = system.file('misc', 'vignette.css', package='knitr'))
```

# Introduction

`saeSim` is a Package for the [R](http://cran.r-project.org/) language. It is developed to make the data simulation process more compact and yet flexible enough for customization. It is designed to suffice in the context of small area estimation. Furthermore, at this time simulation is possible under linear mixed models.

# Data Set-up

A linear mixed model contains two components. A fixed effects part, and an error component. The error component can be split into a random effects part and a model error. All components to be simulated can simply be added to the 'base'. There are several possibilities to create a simulation set-up.

- To begin with, this is the desired approach: `sim_setup(base, ..., R = 500, simName = "")`. The example is the set-up for a linear model:
```{r eval=FALSE}
setup <- sim_setup(sim_base_standard(), sim_gen_fe(), sim_gen_e(), R = 500, 
                   simName = "Doku")
```
- Also it is possible to compose a set-up by using `%&%`. Internally the function `sim_setup` is called and uses it's defaults for all arguments but `base` and `...`:
```{r eval=FALSE}
setup <- sim_base_standard() %&% sim_gen_fe() %&% sim_gen_e()
```
- The set-up itself does not contain the simulated data. To simulate all the data use the function `sim`. This will return a `list` containing `data.frame`s as elements:
```{r eval=FALSE}
dataList <- sim(setup)
```
- Lastly, it is possible to just produce one data set. This approach is mainly used in development but can be useful when exploring the set-up:
```{r eval=FALSE}
simData <- sim(sim_base_standard(), sim_gen_fe(), sim_gen_e())
```

You can also use the following code to add additional components from different set-ups:

```{r eval=FALSE}
setup <- setup %&% sim_gen_rec() %&% sim_gen_ec()
anotherSetup <- sim_setup(sim_base_standard(), R = 5)
setup <- setup %&% anotherSetup
```

In the third line of the above example two set-up objects are combined. What will happen is, that the basic settings (nDomains, nUnits, R, idC, simName) of `anotherSetup` will be used, but all components of the two set-ups are combined.

## sim_base

For the simulation set-up you start with the 'base'. At this time, only one base is defined:

- `sim_base_standard(nDomains = 100, nUnits = 100)` - `nDomains` specify the number of domains/cluster/areas in the data - `nUnits` the number of observations in each domain.


## sim_gen

This section gives an overview of data which can be generated.

### Pre-configured set-ups

There are several pre-configured set-ups you can use for an easy start.

- `sim_lm()` will return a simulation set-up for a linear model, i.e. one regressor and one error component.
- `sim_lmm()` a linear mixed model
- `sim_lmc()` a linear model with contamination in the model error (5% outliers in each area)
- `sim_lmmc()` a linear mixed model with contamination in the model error and random effect (5% outliers in each area and 5% of the areas are outliers)

### Semi-custom data

Data is generated by combining two aspects. First it must be specified how data adds to the model, then it needs to be specified what data it is. There are two ways to specify how data adds to the model, as a fixed or random component. You can use the following functions for that:

- `sim_gen_fe(generator, const = 0, slope = 1, name = "x")` - adding as fixed effects
- `sim_gen_e(generator, name = "e")` - adding as error
- `sim_gen_re(generator, name = "v")` - this a wrapper of `sim_gen_e` providing different defaults

What data is added can be specified for given generators:

- `gen_norm(mean = 0, sd = 1)` - normally distributed variable
- `gen_v_norm(mean = 0, sd = 1)` - normally distributed variable but constant within domain
- `gen_v_sar(mean = 0, sd = 1, rho = 0.5, type = "rook")` - normally distributed variable following a SAR(1), constant within domain

Meaning we can specify a linear mixed model set-up with the regressor `x`, the model error `e` a random effect `v` and a spatially correlated random effect `vSp` as follows:

```{r}
library(saeSim)
setup <- sim_setup(sim_base_standard(), sim_gen_fe(), sim_gen_e(), sim_gen_re(), sim_gen_re(gen_v_sar(), "vSp"))
# This will result in the same set-up:
setup <- sim_lmm() %&% sim_gen_re(gen_v_sar(), "vSp")
```

To get the simulated data as a list (when given to the function `sim` it creates 500 Populations):

```{r eval=FALSE}
dataList <- sim(setup)
```

### Contaminated data

When interested in contamination it is important to know, that the contamination adds additively to the values in the data. This means how data is added to the model changes, the data generators stay the same. If you want a contaminated spatially correlated error component you can add the following to the `setup` object from above:

```{r}
contSetup <- setup %&% 
  sim_gen_rec(gen_v_sar(sd = 40), nCont = 0.05, level = "area", fixed = TRUE, 
              name = "vSp")
```

Note that the generator is the same but with a higher standard deviation. There are two functions for adding contaminated components:

- `sim_gen_ec(generator, nCont = 0.05, level = "unit", fixed = TRUE, name = "e")` - set-up function for a contaminated model error part
- `sim_gen_rec()` - wrapper function of `sim_gen_ec` with different defaults

The 'rec' and 'ec' functions will do the same as the standard functions, however, they add only to a specified set of observations. I.e. the contamination is added additively. How and what random numbers are generated will be controlled via generator functions. The argument `nCont` controls how much observations are contaminated. Values < 1 are interpreted as proportion. A single number as the number of contaminated units (can be areas or observations in each area or observations). When given with `length(nCont) > 1` it will be interpreted as number of contaminated observations in each area. The `level` can be 'area', 'unit' or 'none'; specifying how `nCont` is interpreted. 5% of the observations, 5% of the observations in each area or 5% of the areas. If `fixed` is true in all simulations the same units will be contaminated.

If you use relative numbers for `nCont` the actual number of contaminated observations is rounded up. If the number of contaminated units is larger then the actual, all units will be contaminated.

Use the following example to see how these things play together:

```{r}
sim(sim_base_standard(3, 4), 
    sim_gen_fe(), sim_gen_e(), 
    sim_gen_ec(nCont = c(1, 2, 3), level = "unit", name = "eCont"))
```

### Custom data

You just have to provide your own generator functions. I will explain how that works in time.

## sim_sample

It should be possible to get information from 3 different 'levels'. The population, a sample or the aggregates of the sample. The population is the standard output, so there is nothing to add. For sampling, it is possible to supply a function (the `smpling_*`-functions), which return the positions (or a logical) for selection.

- `sim_sample(smplFun)` - used to add a sampling component to the set-up - the resulting list contains the samples instead of the populations

The `sim_sample` function only controls the role of the component to be added. How samples are drawn can be controlled by the `smplFun`:

- `sample_sampleWrapper(...)` is a wrapper of the sample function already implemented in R. The arguments will simply be passed to `sample`
- `sample_srs(size, ...)` will draw with simple random sampling. `size` can either be >= 1 giving the sample size or < 1 where it is treated as proportion. `...` will be passed to `sample.int`
- `sample_csrs(size, ...)` uses srs within each cluster (domain/area). Additionally `size` can have `length(size) > 1` which will be interpreted as different sample sizes in each domain

Consider the following examples:
```{r}
sim(sim_base_standard(3, 4), sim_gen_fe(), sim_sample(sample_srs(1L)))
sim(sim_base_standard(3, 4), sim_gen_fe(), sim_sample(sample_csrs(1L)))
```

```{r eval=FALSE}
# simple random sampling:
setup %&% sim_sample(sample_srs(size = 10L))
setup %&% sim_sample(sample_srs(size = 0.05))
# srs in each domain/cluster
setup %&% sim_sample(sample_csrs(size = 10L))
setup %&% sim_sample(sample_csrs(size = rep(10L, 100)))
setup %&% sim_sample(sample_csrs(size = 0.05))
```

## sim_agg

If you are interested in aggregated information you can either draw directly from the model when specifying `nUnits = 1` or use the aggregate component. Aggregating the data is another component which can be used on the population or sample. The aggregation will simply be done after the sampling, if you haven't specified any sampling component, the population is aggregated (makes sense if you draw samples directly from the model). The variable `idU` will be lost. All variables including `idC` will be `TRUE` if any of the non-aggregated values is `TRUE` - this holds for all logical variables in the data. For categorical data (character or factor) the modus is taken. For numerical variables the mean will be taken.

```{r}
sim_setup(setup, sim_agg())
```


## sim_calc

In addition you may want to keep some information from the population or sample. That is why you can calculate some additional variables on the data. For contaminated data you want to further specify if the outlying observations should be used for calculating those statistics - for that you can supply one or more indicator variables in the data.

- `sim_calc(calcFun, level = "population")` - `level` can be "population" or "sample" determining of the calculation is made on the population or after sampling - if no sampling is added the argument has no effect

Of course the real workhorse is the `calcFun`. At this time you can only calculate something for each domain using the following 'calculator':

- `calc_var(varName = "y", funList = list(mean = mean, var = var), exclude = NULL, by = "idD", newName = varName)` - `exclude` will determine if any of the observations will be excluded from the calculation

Consider the following examples to see how this function can be used:  
  
```{r}
sim(sim_base_standard(3, 4), sim_gen_fe(), sim_gen_e(), sim_gen_ec(), 
    sim_calc(calc_var(varName = "y", funList = list(mean = mean, var = var), 
                      exclude = "idC", by = "idD"), level = "population"))
sim(sim_base_standard(3, 4), sim_gen_fe(), sim_gen_e(), sim_gen_ec(), 
    sim_calc(calc_var(varName = "y", funList = list(mean = mean, var = var), 
                      exclude = NULL, by = "idD"), level = "population"))
setup %&% sim_calc(calc_var(varName = "y", funList = list(length), newName = "N"), 
                   level = "population")
setup %&% 
  sim_sample() %&%
  sim_calc(calc_var(varName = "y", funList = list(length), newName = "n"), 
           level = "sample")
```


### Pre-configured sim_calc components

Since these specifications above can get lengthy and annoying there are some convenience functions (remember that all statistics are calculated within each domain):

- `sim_n()` - adds the sample sizes in `n`
- `sim_N()` - adds the population N in `N`
- `sim_popMean()` - adds the population means
- `sim_popVar()` - adds the population variances

```{r}
sim(sim_base_standard(3, 4), sim_gen_fe(), sim_gen_e(), sim_gen_ec(), sim_popMean())
```


## Methods

You will want to check your results regularly to see how things will work out. When working with set-up objects there are some methods supplied to do that, without simulating redundant data all the time:

- `show` - this is the `print` method for S4-Classes. You don't have to call `show` explicitly
- `plot` - will call `smoothScatter` for visualizing the data
- `autoplot` - I am unable to annotate graphics from the package `graphics`, that's why I need a plotting function using `ggplot2`. Will imitate `smoothScatter` see [this article](http://wahani.github.io/PlotNo1/) if you should be interested in how it works

```{r}
setup
plot(setup)
autoplot(setup)
autoplot(setup, "e")
```

One of the nice things about this package is, that it is extremely easy to explore how different set-up component will influence the results:

```{r}
autoplot(setup %&% sim_gen_rec())
```